x = bird_hab$ls,
y_int = int_obs,
slope = slope_obs,
st_dev = sd_obs
)
fit_sim = lm(y_sim ~ bird_hab$ls)
summary(fit_sim)
#matrix of coeffs
sum_1 = summary(fit_sim)
sum_1$coefficients
sum_1$coefficients[2, 4]
n_sims = 1000
p_vals = numeric(n_sims)
alpha = 0.05
for(i in 1:n_sims)
{
y_sim = linear_simulator(
x = birdhab$ls,
y_int = int_obs,
slope = slope_obs,
st_dev = sd_obs
)
fit_sim = lm(y_sim ~ birdhab$ls)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
n_sims = 1000
p_vals = numeric(n_sims)
alpha = 0.05
for(i in 1:n_sims)
{
y_sim = linear_simulator(
x = bird_hab$ls,
y_int = int_obs,
slope = slope_obs,
st_dev = sd_obs
)
fit_sim = lm(y_sim ~ bird_hab$ls)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
sum(p_vals < alpha) / n_sims
linear_sim_fit = function(x, slope, y_int, st_dev)
{
y_sim = linear_simulator(
x = x,
y_int = y_int,
slope = slope,
st_dev = st_dev
)
fit_sim = lm(y_sim ~ x)
return(fit_sim)
}
alpha = 0.05
n_sims = 1000
p_vals = numeric(n_sims)
n_effect_sizes = 20
effect_sizes_1 = seq(-.01, .01, length.out = n_effect_sizes)
effect_size_powers = numeric(n_effect_sizes)
for(j in 1:n_effect_sizes)
{
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = birdhab$ls,
y_int = int_obs,
slope = effect_sizes_1[j],
st_dev = sd_obs
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
effect_size_powers[j] = sum(p_vals < alpha) / n_sims
}
alpha = 0.05
n_sims = 1000
p_vals = numeric(n_sims)
n_effect_sizes = 20
effect_sizes_1 = seq(-.01, .01, length.out = n_effect_sizes)
effect_size_powers = numeric(n_effect_sizes)
for(j in 1:n_effect_sizes)
{
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = bird_hab$ls,
y_int = int_obs,
slope = effect_sizes_1[j],
st_dev = sd_obs
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
effect_size_powers[j] = sum(p_vals < alpha) / n_sims
}
sim_effect_size =
data.frame(
effect_size = effect_sizes_1,
power       = effect_size_powers)
plot(
power ~ effect_size, data = sim_effect_size,
type = 'l', xlab = 'Effect size', ylab = 'Power')
abline(v = slope_obs, lty = 2, col = 'red')
alpha = 0.05
n_sims = 1000
p_vals = numeric(n_sims)
sample_sizes = seq(5, 100)
sample_size_powers = numeric(length(sample_sizes))
# The maximum x value in the simulation.
# Use the maximum observed x-value in the data
max_x = max(birdhab$ls)
#simulating sample size
alpha = 0.05
n_sims = 1000
p_vals = numeric(n_sims)
sample_sizes = seq(5, 100)
sample_size_powers = numeric(length(sample_sizes))
# The maximum x value in the simulation.
# Use the maximum observed x-value in the data
max_x = max(bird_hab$ls)
for(j in 1:length(sample_sizes))
{
# A sequence of equally-spaced x-values:
x_vals = seq(0, max_x, length.out = sample_sizes[j])
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = x_vals,
y_int = int_obs,
slope = slope_obs,
st_dev = sd_obs
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
sample_size_powers[j] = sum(p_vals < alpha) / n_sims
}
sim_sample_size =
data.frame(
sample_size = sample_sizes,
power       = sample_size_powers)
sim_sample_size =
data.frame(
sample_size = sample_sizes,
power       = sample_size_powers)
plot(
power ~ sample_size, data = sim_sample_size,
type = 'l', xlab = 'Sample size', ylab = 'Power')
abline(v = nrow(birdhab), lty = 2, col = 'red')
plot(
power ~ sample_size, data = sim_sample_size,
type = 'l', xlab = 'Sample size', ylab = 'Power')
abline(v = nrow(bird_hab), lty = 2, col = 'red')
alpha = 0.01
n_sims = 50
p_vals = numeric(n_sims)
n_effect_sizes = 20
effect_sizes = seq(-.01, .01, length.out = n_effect_sizes)
# The maximum x value in the simulation.
# Use the maximum observed x-value in the data
max_x = max(birdhab$ls)
alpha = 0.01
n_sims = 50
p_vals = numeric(n_sims)
n_effect_sizes = 20
effect_sizes = seq(-.01, .01, length.out = n_effect_sizes)
# The maximum x value in the simulation.
# Use the maximum observed x-value in the data
max_x = max(bird_hab$ls)
sample_sizes = seq(10, 50)
sim_output_2 = matrix(nrow = length(effect_sizes), ncol = length(sample_sizes))
for(k in 1:length(effect_sizes))
{
effect_size = effect_sizes[k]
for(j in 1:length(sample_sizes))
{
x_vals = seq(0, max_x, length.out = sample_sizes[j])
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = x_vals,
y_int = int_obs,
slope = effect_size,
st_dev = sd_obs
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
sim_output_2[k, j] = sum(p_vals < alpha) / n_sims
}
print(paste0("computing effect size ", k," of ", length(effect_sizes)))
}
sim_n_effect_size =
list(
power = sim_output_2,
effect_size = effect_sizes,
sample_size = sample_sizes
)
image(
sim_n_effect_size$power,
xlab = "Effect size",
ylab = "Sample Size",
axes = FALSE)
# add x-axis labels
axis(
1,
at = c(0, 0.5, 1),
labels = c(-.01, 0.0, .01))
# add y=axis labels
axis(
2,
at = c(0, 1),
labels = c(sample_sizes[1], tail(sample_sizes, 1)))
#contour plotting
contour(
x = sim_n_effect_size$effect_size,
y = sim_n_effect_size$sample_size,
z = sim_n_effect_size$power,
xlab = "effect size",
ylab = "sample size",
main = "Contour Plot of Statistical Power",
levels = seq(0, 1, length.out = 9),
drawlabels = TRUE,
# method = "simple")
method = "edge")
#3D plot
persp(
x = sim_n_effect_size$effect_size,
y = sim_n_effect_size$sample_size,
z = sim_n_effect_size$power,
xlab = "beta", ylab = "n", zlab = "power",
col = 'lightblue',
theta = 30, phi = 30, expand = .75,
ticktype = 'detailed')
install.packages('rgl')
persp3d(
x = sim_n_effect_size$effect_size,
y = sim_n_effect_size$sample_size,
z = sim_n_effect_size$power,
xlab = "beta", ylab = "n", zlab = "power",
col = 'lightblue',
theta = 30, phi = 30, expand = .75,
ticktype = 'detailed')
require(persp3d)
persp3d(
x = sim_n_effect_size$effect_size,
y = sim_n_effect_size$sample_size,
z = sim_n_effect_size$power,
xlab = "beta", ylab = "n", zlab = "power",
col = 'lightblue',
theta = 30, phi = 30, expand = .75,
ticktype = 'detailed')
require(persp3d)
persp3d(
x = sim_n_effect_size$effect_size,
y = sim_n_effect_size$sample_size,
z = sim_n_effect_size$power,
xlab = "beta", ylab = "n", zlab = "power",
col = 'lightblue',
theta = 30, phi = 30, expand = .75,
ticktype = 'detailed')
require(persp3d)
persp3d(
x = sim_n_effect_size$effect_size,
y = sim_n_effect_size$sample_size,
z = sim_n_effect_size$power,
xlab = "beta", ylab = "n", zlab = "power",
col = 'lightblue',
theta = 30, phi = 30, expand = .75,
ticktype = 'detailed')
require(persp3d)
require(rgl)
persp3d(
x = sim_n_effect_size$effect_size,
y = sim_n_effect_size$sample_size,
z = sim_n_effect_size$power,
xlab = "beta", ylab = "n", zlab = "power",
col = 'lightblue',
theta = 30, phi = 30, expand = .75,
ticktype = 'detailed')
#saving the plot
require(htmlwidgets)
#saving the plot
require(htmlwidgets)
saveWidget(
rglwidget(),
file = here(
"docs", "webGL",
"n_effect_size_power_sim_plot.html"),
selfcontained = TRUE
)
require(htmlwidgets)
saveWidget(
rglwidget(),
file = here(
"docs", "webGL",
"n_effect_size_power_sim_plot.html"),
selfcontained = TRUE
)
saveWidget(
rglwidget(),
file = here(
"labs",
"n_effect_size_power_sim_plot.html"),
selfcontained = TRUE
)
p_vals = numeric(n_sims)
pop_sds = seq(from = 0.01, to = 1.5, length.out = n_sds)
# specify the number of different standard deviation values to simulate:
n_sds = 20
pop_sds = seq(from = 0.01, to = 1.5, length.out = n_sds)
pop_sd_j = pop_sds[j]
alpha = 0.05
n_sims = 100
p_vals = numeric(n_sims)
# What was the observed standard deviation?
sd_obs
# specify the number of different standard deviation values to simulate:
n_sds = 20
pop_sds = seq(from = 0.01, to = 1.5, length.out = n_sds)
pop_sd_powers = numeric(n_sds)
for(j in 1:length(pop_sds))
{
pop_sd_j = pop_sds[j]
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(x = pop_sds,
y_int = alpha,
slope = pop_sd_j,
st_dev = sd_obs)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
pop_sd_powers[j] = numeric(length(pop_sds))
}
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(x = sd, y = pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# You should save your simulation results so you don't have to run it every time.
save(
sim_output_dispersion,
file = here::here("data", "lab_ll_dat_dispersion_sim.RData"))
sim_output_dispersion = data.frame(
sd = pop_sds,
power = pop_sd_powers)
# You should save your simulation results so you don't have to run it every time.
save(
sim_output_dispersion,
file = here::here("data", "lab_ll_dat_dispersion_sim.RData"))
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(x = sd, y = pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(x = sd, y = power, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(sd ~ power, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(sd,  power, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds ~ pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
sim_output_dispersion = data.frame(
sd = pop_sds,
power = pop_sd_powers)
alpha = 0.05
n_sims = 100
p_vals = numeric(n_sims)
# What was the observed standard deviation?
sd_obs
# specify the number of different standard deviation values to simulate:
n_sds = 20
pop_sds = seq(from = 0.01, to = 1.5, length.out = n_sds)
pop_sd_powers = numeric(n_sds)
for(j in 1:length(pop_sds))
{
pop_sd_j = pop_sds[j]
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = bird_bad$ls,
y_int = int_obs,
slope = slope_obs,
st_dev = pop_sd_j
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
pop_sd_powers[j] = sum(p_vals < alpha) / n_sims
}
pop_sd_powers = numeric(n_sds)
for(j in 1:length(pop_sds))
{
pop_sd_j = pop_sds[j]
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = bird_bad$ls,
y_int = int_obs,
slope = slope_obs,
st_dev = pop_sd_j
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
pop_sd_powers[j] = sum(p_vals < alpha) / n_sims
}
alpha = 0.05
n_sims = 100
p_vals = numeric(n_sims)
# What was the observed standard deviation?
sd_obs
# specify the number of different standard deviation values to simulate:
n_sds = 20
pop_sds = seq(from = 0.01, to = 1.5, length.out = n_sds)
pop_sd_powers = numeric(n_sds)
for(j in 1:length(pop_sds))
{
pop_sd_j = pop_sds[j]
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = bird_hab$ls,
y_int = int_obs,
slope = slope_obs,
st_dev = pop_sd_j
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
pop_sd_powers[j] = sum(p_vals < alpha) / n_sims
}
sim_output_dispersion = data.frame(
sd = pop_sds,
power = pop_sd_powers)
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(sd, power, xlab = 'Dispersion', ylab = 'Statistical Power')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# Add a dotted vertical red line at the observed population standard deviation value.
abline(v = sd_obs, col = red)
# Add a dotted vertical red line at the observed population standard deviation value.
abline(v = sd_obs, col = 'red')
pop_sd_powers = numeric(length(n_sds))
#########################
alpha = 0.05
n_sims = 100
p_vals = numeric(n_sims)
# What was the observed standard deviation?
sd_obs
# specify the number of different standard deviation values to simulate:
n_sds = 20
pop_sds = seq(from = 0.01, to = 1.5, length.out = n_sds)
pop_sd_powers = numeric(length(n_sds))
for(j in 1:length(pop_sds))
{
pop_sd_j = pop_sds[j]
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = bird_hab$ls,
y_int = int_obs,
slope = slope_obs,
st_dev = pop_sds_j
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
pop_sd_powers[j] = sum(p_vals < alpha) / n_sims
}
for(j in 1:length(pop_sds))
{
pop_sd_j = pop_sds[j]
for(i in 1:n_sims)
{
fit_sim = linear_sim_fit(
x = bird_hab$ls,
y_int = int_obs,
slope = slope_obs,
st_dev = pop_sds[j]
)
p_vals[i] = summary(fit_sim)$coefficients[2, 'Pr(>|t|)']
}
pop_sd_powers[j] = sum(p_vals < alpha) / n_sims
}
sim_output_dispersion = data.frame(
sd = pop_sds,
power = pop_sd_powers)
# You should save your simulation results so you don't have to run it every time.
save(
sim_output_dispersion,
file = here::here("data", "lab_ll_dat_dispersion_sim.RData"))
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# Add a dotted vertical red line at the observed population standard deviation value.
abline(v = sd_obs, col = 'red')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power', lty = 2)
# Add a dotted vertical red line at the observed population standard deviation value.
abline(v = sd_obs, col = 'red')
# Add a dotted vertical red line at the observed population standard deviation value.
abline(v = sd_obs, col = 'red', lty = 2)
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power')
# Add a dotted vertical red line at the observed population standard deviation value.
abline(v = sd_obs, col = 'red', lty = 2)
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power', type = 1)
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power', type = "1")
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power', type = "line")
# Add a dotted vertical red line at the observed population standard deviation value.
abline(v = sd_obs, col = 'red')
# Line plot of standard deviation (x-axis) and statistical power (y-axis)
plot(pop_sds, pop_sd_powers, xlab = 'Dispersion', ylab = 'Statistical Power', type = "line", main = 'Statistical Power vs Dispersion')
# Add a dotted vertical red line at the observed population standard deviation value.
abline(v = sd_obs, col = 'red')
?contour
